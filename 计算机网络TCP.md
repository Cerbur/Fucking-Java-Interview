# TCP的一些常见问题

## [经典面试题]TCP 头

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210717174731.png)

### 序列号

在建⽴连接时由计算机⽣成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就 「累加」⼀次该「数据字节数」的⼤⼩。⽤来解决⽹络包乱序问题。

### 确认应答号

指下⼀次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数 据都已经被正常接收。⽤来解决不丢包的问题。 

### 控制位

 ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必 须设置为 1 。 RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。 SYN：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定。 FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的 主机之间就可以相互交换 FIN 位为 1 的 TCP 段。

## TCP 是⾯向连接的、可靠的、基于字节流的传输层通信协议。

## TCP 四元组

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210717175109.png)

## [经典面试题]之TCP最大连接数

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210717175041.png)

## UDP 头

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210717175151.png)

## TCP 和 UDP 区别

1. 连接

    TCP 是⾯向连接的传输层协议，传输数据前先要建⽴连接。 UDP 是不需要连接，即刻传输数据。 

2. 服务对象

    TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点。 UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信 

3. 可靠性

    TCP 是可靠交付数据的，数据可以⽆差错、不丢失、不重复、按需到达。 UDP 是尽最⼤努⼒交付，不保证可靠交付数据。 

4. 拥塞控制、流量控制

    TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。 UDP 则没有，即使⽹络⾮常拥堵了，也不会影响 UDP 的发送速率。 

5. ⾸部开销 

   TCP ⾸部⻓度较⻓，会有⼀定的开销，⾸部在没有使⽤「选项」字段时是 20 个字节，如果使⽤了「选项」 字段则会变⻓的。 UDP ⾸部只有 8 个字节，并且是固定不变的，开销较⼩。 

6. 传输⽅式 

   TCP 是流式传输，没有边界，但保证顺序和可靠。 UDP 是⼀个包⼀个包的发送，是有边界的，但可能会丢包和乱序。 

7. 分⽚不同 

   - TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在传输层进⾏分⽚，⽬标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚。 

   - UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据，接着 再传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要᯿传所有的数据包，这样 传输效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU。

## TCP 和 UDP 应⽤场景

TCP：FTP ⽂件传输，HTTP / HTTPS

UDP：包总量较少的通信，如 DNS 、 SNMP 等，视频、⾳频等多媒体通信，⼴播通信

## 为什么 UDP 头部没有「⾸部⻓度」字段，⽽ TCP 头部有「⾸部⻓度」字段呢

原因是 TCP 有可变⻓的「选项」字段，⽽ UDP 头部⻓度则是不会变化的，⽆需多⼀个字段去记录 UDP 的⾸部⻓度。

## 为什么 UDP 头部有「包⻓度」字段，⽽ TCP 头部则没有「包⻓度」字段呢？

首先我们明确一下，TCP是有首部长度也就是知道 TCP 头的长度的，而不知道数据的长度。而 UDP 有包长度，首部长度固定，包长度就是头长度和数据长度的总和。

先说说 TCP 是如何计算负载数据⻓度：

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210717180350.png)

其中 IP 总⻓度 和 IP ⾸部⻓度，在 IP ⾸部格式是已知的。TCP ⾸部⻓度，则是在 TCP ⾸部格式已知的，所以就可以求得 TCP 数据的⻓度。 

⼤家这时就奇怪了问：“ UDP 也是基于 IP 层的呀，那 UDP 的数据⻓度也可以通过这个公式计算呀？ 为何还要有 「包⻓度」呢？” 

这么⼀问，确实感觉 UDP 「包⻓度」是冗余的。

因为为了⽹络设备硬件设计和处理⽅便，**⾸部⻓度需要是 4 字节的整数倍**。 如果去掉 UDP 「包⻓度」字段，那 UDP ⾸部⻓度就不是 4 字节的整数倍了，所以这可能是为了补全 UDP ⾸部⻓度是 4 字节的整数倍，才补充了「包⻓度」字段。

## [经典面试题]TCP三次握手

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210717180635.png)

第三次握⼿是可以携带数据的，前两次握⼿是不可以携带数据的。

## [经典面试题] 为什么是三次握⼿？不是两次、四次？

相信⼤家⽐较常回答的是：“因为三次握⼿才能保证双⽅具有接收和发送的能⼒。” 

这回答是没问题，但这回答是⽚⾯的，并没有说出主要的原因。 

在前⾯我们知道了什么是 TCP 连接： ⽤于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗⼝⼤⼩称为连接。 所以，重要的是为什么三次握⼿才可以初始化Socket、序列号和窗⼝⼤⼩并建⽴ TCP 连接。 

接下来以三个⽅⾯分析三次握⼿的原因： 

三次握⼿才可以阻⽌重复历史连接的初始化（主要原因） 

三次握⼿才可以同步双⽅的初始序列号 

三次握⼿才可以避免资源浪费

## **既然 IP 层会分⽚，为什么 TCP 层还需要 MSS 呢？**

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210717181610.png)

如果在 TCP 的整个报⽂（头部 + 数据）交给 IP 层进⾏分⽚，会有什么异常呢？ 

当 IP 层有⼀个超过 MTU ⼤⼩的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进⾏分⽚，把数据分⽚成若⼲⽚，保证每⼀个分⽚都⼩于 MTU。把⼀份 IP 数据报进⾏分⽚以后，由⽬标主机的 IP 层来进⾏重新组装后， 再交给上⼀层 TCP 传输层。 这看起来井然有序，但这存在隐患的，那么当如果⼀个 IP 分⽚丢失，整个 IP 报⽂的所有分⽚都得重传。 因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。

 当接收⽅发现 TCP 报⽂（头部 + 数据）的某⼀⽚丢失后，则不会响应 ACK 给对⽅，那么发送⽅的 TCP 在超时 后，就会重发「整个 TCP 报⽂（头部 + 数据）」。 因此，可以得知由 IP 层进⾏分⽚传输，是⾮常没有效率的。 所以，为了达到最佳的传输效能 TCP 协议在建⽴连接的时候通常要协商双⽅的 MSS 值，当 TCP 层发现数据超过 MSS 时，则就先会进⾏分⽚，当然由它形成的 IP 包的⻓度也就不会⼤于 MTU ，⾃然也就不⽤ IP 分⽚了。

## [经典面试题]什么是 SYN 攻击？如何避免 SYN 攻击？

### SYN 攻击 

我们都知道 TCP 连接建⽴是需要三次握⼿，假设攻击者短时间伪造不同 IP 地址的 SYN 报⽂，服务端每接收到 ⼀个 SYN 报⽂，就进⼊ SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报⽂，⽆法得到未知 IP 主机的 ACK 应答，久⽽久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常⽤户服务。

### 避免 SYN 攻击⽅式

其中⼀种解决⽅式是通过修改 Linux 内核参数，控制队列⼤⼩和当队列满时应做什么处理。

SYN cookie

## [经典面试题]TCP 连接断开

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210717182055.png)

### [经典面试题]为什么挥⼿需要四次？

再来回顾下四次挥⼿双⽅发 FIN 包的过程，就能理解为什么需要四次了。

关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 

服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂，⽽服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接。

### [经典面试题]为什么 TIME_WAIT 等待的时间是 2MSL？

原因⼀：防⽌旧连接的数据包

保证连接正确关闭

- 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端
- 1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达

## [经典面试题]TCP 的重传机制、滑动窗⼝、流量控制、拥塞控制

### 重传机制

#### 超时重传

重传机制的其中⼀个⽅式，就是在发送数据时，设定⼀个定时器，当超过指定的时间后，没有收到对⽅的 ACK 确认应答报⽂，就会᯿发该数据，也就是我们常说的超时重传。

#### 快速重传

TCP 还有另外⼀种快速重传（Fast Retransmit）机制，它不以时间为驱动，⽽是以数据驱动重传。

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210717190056.png)

### 滑动窗⼝、流量控制

TCP 头⾥有⼀个字段叫 Window ，也就是窗⼝⼤⼩。 这个字段是**接收端告诉发送端⾃⼰还有多少缓冲区**可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来 发送数据，⽽不会导致接收端处理不过来。

### 拥塞控制

#### 慢启动

连接建⽴完成后，⼀开始初始化 cwnd = 1 ，表示可以传⼀个 MSS ⼤⼩的数据。 

当收到⼀个 ACK 确认应答后，cwnd 增加 1，于是⼀次能够发送 2 个 当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以⽐之前多发2 个，所以这⼀次能够发送 4 个 当这 4 个的 ACK 确认到来的时候，

每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以⽐之前多发 4 个，所以这⼀次能够发送 8 个。

#### 拥塞避免

有⼀个叫慢启动⻔限 ssthresh （slow start threshold）状态变量。 当 cwnd < ssthresh 时，使⽤慢启动算法。 当 cwnd >= ssthresh 时，就会使⽤「拥塞避免算法」。

当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd ⼀共增加 1，于是这⼀次能够发送 9 个 MSS ⼤⼩的数据，变成了**线性增⻓**。

#### 拥塞发⽣

当发⽣了「超时重传」，则就会使⽤拥塞发⽣算法。

ssthresh 设为 cwnd/2 ， cwnd 重置为 1

#### 快速恢复

快速重传和快速恢复算法⼀般同时使⽤，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明⽹络也不那么糟 糕，所以没有必要像 RTO 超时那么强烈。

拥塞窗⼝ cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）； 

重传丢失的数据包； 如果再收到重复的 ACK，那么 cwnd 增加 1；

 如果收到新数据的 ACK 后，把 cwnd 设置为第⼀步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说 明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进 ⼊拥塞避免状态；