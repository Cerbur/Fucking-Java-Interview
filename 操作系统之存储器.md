# 操作系统之存储器

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210723004228.png)

对于存储器，它的速度越快、能耗会越⾼、⽽且材料的成本也是越贵的，以⾄于速度快的存储器的容量都 ⽐较⼩。

## 存储金字塔

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210723004356.png)

每个存储器只和相邻的⼀层存储器设备打交道，并且存储设备为了追求更快的速度，所需的材料成本必然也是更⾼，也正因为成本太⾼，所以 CPU 内部的寄存器、L1\L2\L3 Cache 只好⽤较⼩的容量，相 反内存、硬盘则可⽤更⼤的容量，这就我们今天所说的存储器层次结构。

## 通过二维数组了解一些如果让CPU跑的更快的代码

我们知道 CPU 访问内存的速度，⽐访问 CPU Cache 的速度慢了 100 多倍，所以如果 CPU 所要操作的数 据在 CPU Cache 中的话，这样将会带来很⼤的性能提升。访问的数据在 CPU Cache 中的话，意味着缓存 命中，缓存命中率越⾼的话，代码的性能就会越好，CPU 也就跑的越快。

L1 Cache 通常分为「数据缓存」和「指令缓存」，这是因为 CPU 会别处理数据和指 令，⽐如 1+1=2 这个运算， + 就是指令，会被放在「指令缓存」中，⽽输⼊数字 1 则会被放在「数 据缓存」⾥。 因此，我们要分开来看「数据缓存」和「指令缓存」的缓存命中率。

### 如何提升数据缓存的命中率？

以下是两种二维数组的遍历

```java
int[][] array = new int[N][N];

// 1
for (int i = 0; i < N; i ++) {
  for (int j = 0; i < N; j ++) {
    array[i][j] = 0;
  }
}

// 2
for (int i = 0; i < N; i ++) {
  for (int j = 0; i < N; j ++) {
    array[j][i] = 0;
  }
}
```

经过测试，形式⼀ `array[i][j]` 执⾏时间⽐形式⼆ `array[j][i]` 快好⼏倍。

之所以有这么⼤的差距，是因为⼆维数组 array 所占⽤的内存是连续的，⽐如⻓度 N 的指是 2 的 话，那么内存中的数组元素的布局顺序是这样的：

```
array[0][0],array[0][1],array[1][0],array[1][1]
```

形式⼀⽤` array[i][j] `访问数组元素的顺序，正是和内存中数组元素存放的顺序⼀致。当 CPU 访问 `array[0][0] `时，由于该数据不在 Cache 中，于是会「顺序」把跟随其后的 3 个元素从内存中加载到 CPU Cache，这样当 CPU 访问后⾯的 3 个数组元素时，就能在 CPU Cache 中成功地找到数据，这意味着缓存 命中率很⾼，缓存命中的数据不需要访问内存，这便⼤⼤提⾼了代码的性能。



⽽如果⽤形式⼆的 array[j][i] 来访问，则访问的顺序就是：

```
array[0][0],array[1][0],array[0][1],array[1][1]
```

你可以看到，访问的⽅式跳跃式的，⽽不是顺序的，那么如果 N 的数值很⼤，那么操作` array[j][i] `时，是 没办法把 `array[j+1][i] `也读⼊到 CPU Cache 中的，既然` array[j+1][i] `没有读取到 CPU Cache，那么就 需要从内存读取该数据元素了。很明显，这种不连续性、跳跃式访问数据元素的⽅式，可能不能充分利⽤ 到了 CPU Cache 的特性，从⽽代码的性能不⾼。

### 如何提升指令缓存的命中率？

#### 分⽀预测器

```c
int array[N];
for (i = 0; i < N; i++) {
  array[i] = rand() % 100;
}
```

如何进行操作

```c
// 操作1
for (i = 0; i < N; i++) {
  if (array[i] < 50) {
    array[i] = 0;
  }
}

// 操作2

sort(array,array + N);
```

第⼀个操作，循环遍历数组，把⼩于 50 的数组元素置为 0； 第⼆个操作，将数组排序； 那么问题来了，你觉得先遍历再排序速度快，还是先排序再遍历速度快呢?

对于 if 条件语句，意味着此时⾄少可以选择跳转 到两段不同的指令执⾏，也就是 if 还是 else 中的指令。那么，如果分⽀预测可以预测到接下来要执⾏ if ⾥ 的指令，还是 else 指令的话，就可以「提前」把这些指令放在指令缓存中，这样 CPU 可以直接从 Cache 读取到指令，于是执⾏速度就会很快。

当数组中的元素是随机的，分⽀预测就⽆法有效⼯作，⽽当数组元素都是是顺序的，分⽀预测器会动态地 根据历史命中数据对未来进⾏预测，这样命中率就会很⾼。

因此，先排序再遍历速度会更快，这是因为排序之后，数字是从⼩到⼤的，那么前⼏次循环命中 if < 50 的次数会⽐较多，于是分⽀预测就会缓存 if ⾥的 array[i] = 0 指令到 Cache 中，后续 CPU 执⾏该指令 就只需要从 Cache 读取就好了。

简单来说，如果 true 概率比较高，他对于的指令会被缓存