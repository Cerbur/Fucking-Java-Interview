# MySQL索引

InnoDB 下存储所用的索引数据结构是B+树，其实也就是一个双向链表的N+树这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。

树越高，发生磁盘读取的次数就越多，所以N叉树在这里的使用是比二叉树来的高效。

B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210715022048.png)

这是InnoDB的索引组织结构

在InnoDB下主键索引也是数据直接存放的地方，他包括所有的数据行，所有的数据都存在B+树的叶子结点中。在InnoDB里，主键索引也被称为聚簇索引。

非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。



## 回表

根据上面的索引结构说明，我们来讨论一个问题：**基于主键索引和普通索引的查询有什么区别？**

- 如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；
- 如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。

## 不定义主键会怎么样

InnoDB对数据的存储必须依赖于主键，那么对于没有创建主键的表，该怎么办？

InnoDB对聚簇索引处理如下： - 如果定义了主键，那么InnoDB会使用主键作为聚簇索引 - 如果没有定义主键，那么会使用第一非空的唯一索引（NOT NULL and UNIQUE INDEX）作为聚簇索引 - 如果既没有主键也找不到合适的非空索引，那么InnoDB会自动生成一个不可见的名为ROW_ID的列名为GEN_CLUST_INDEX的聚簇索引，该列是一个6字节的自增数值，随着插入而自增。

## 如何选择主键

主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。

有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：

1. 只有一个索引；
2. 该索引必须是唯一索引。

你一定看出来了，这就是典型的KV场景。由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。

## 覆盖索引

如果我们所查的索引上就有我们需要的数据，则不用回表到主键索引既可以获取到数据，可以优化查询时间。我们可以对一些高频的查询创建联合索引，即使所联合的索引大概率我们不需要他做查询，但可以减少我们回表所需要的时间。比如在身份证和姓名这个案例中，我们会高频的通过身份证查询姓名，将他们作为一个联合索引可以减少回表获取姓名所需要的时间。

## 最左前缀原则

如果表拥有一个联合索引, 任何一个索引的最左前缀都会被优化器用于查找列. 比如, 如果你创建了一个三列的联合索引包含(col1, col2, col3), 你的索引会生效于(col1), (col1, col2), 以及(col1, col2, col3)。如果查询的列不是索引的最左前缀, 那MySQL不会将索引用于执行查询.

1.最左前缀原则, 即如果你创建一个联合索引, 那 这个索引的任何前缀都会用于查询, (col1, col2, col3)这个联合索引的所有前缀 就是(col1), (col1, col2), (col1, col2, col3), 包含这些列的查询都会启用索引查询.
 2.其他所有不在最左前缀里的列都不会启用索引, 即使包含了联合索引里的部分列 也不行. 即上述中的(col2), (col3), (col2, col3) 都不会启用索引去查询.
 **注意, (col1, col3)会启用(col1)的索引查询**