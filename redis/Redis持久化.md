# Redis 持久化

## AOF 日志

AOF 就是 Redis 中对所有的写操作的记录日志，在数据库中默认不开启

### 优点

1. 避免额外的检查开销

   AOF 操作实在写操作执行成功后才会进行写入日志，那么 AOF 日志中的命令都是可以被正确执行的

2. 不会阻塞当前写操作的执行

   因为 AOF 是在写操作执行成功之后执行的，所以不会阻塞当前的写操作

### 缺点

1. 有丢失的风险

   Redis 还没来得及写入硬盘中，服务器宕机了，数据就发生了丢失

2. 可能给下一个命令带来阻塞的风险

   都是主进程进行命令的执行和写日志的操作，所以有可能会阻塞下一个命令的执行

### 写回策略

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210713194853.png)

### AOF重写机制

为了避免 AOF 文件过大，当 AOF 文件超过阈值后，Redis 启用 AOF 重写机制，压缩 AOF 文件。可以理解为压缩后只存储最新的状态。重写 AOF 的时候，不直接复用现有的 AOF 文件，而是先写到新的 AOF 文件再覆盖过去。因为**如果 AOF 重写过程中失败了，现有的 AOF 文件就会造成污染**，可能无法用于恢复使用。

### AOF后台重写

Redis 的重写 AOF 过程是由后台子进程来完成的这样做的优点有

1. 子进程进行 AOF 重写期间，主进程可以继续处理指令避免阻塞
2. 子进程可以和主进程共享内存数据。不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。



#### 写时复制

子进程是怎么拥有主进程一样的数据副本的呢？

主进程在通过 `fork` 系统调用生成 bgrewriteaof 子进程时，操作系统会把主进程的「**页表**」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210714034204.png)

这样一来，子进程就共享了父进程的物理内存数据了，这样能够**节约物理内存资源**，页表对应的页表项的属性会标记该物理内存的权限为**只读**。

不过，当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发**缺页中断**，这个缺页中断是由于违反权限导致的，然后操作系统会在「缺页异常处理函数」里进行**物理内存的复制**，并重新设置其内存映射关系，将父子进程的内存读写权限设置为**可读写**，最后才会对内存进行写操作，这个过程被称为「**写时复制(\*Copy On Write\*)**」。

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210714034212.png)

写时复制顾名思义，**在发生写操作的时候，操作系统才会去复制物理内存**，这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。

所以，有两个阶段会导致阻塞父进程：

- 创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；
- 创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长；

## RDB

RDB 快照，RDB 文件的内容是二进制数据。RDB 文件的加载工作是在服务器启动时自动执行的，Redis 并没有提供专门用于加载 RDB 文件的命令。

Redis 提供了两个命令来生成 RDB 文件，分别是 `save` 和 `bgsave`，他们的区别就在于是否在「主线程」里执行。

执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，如果写入 RDB 文件时间太长就会阻塞主线程。

执行 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样就可以避免主线程阻塞。



bgsave 也是通过 fork 一个子进程进行 RDB文件写入，如果主线程发生操作命令，就会触发写时复制。

## RDB 和 AOF 合体

尽管 RDB 比 AOF 的数据恢复速度快，但是快照的频率不好把握：

- 如果频率太低，两次快照间一旦服务器发生宕机，就可能会比较多的数据丢失；
- 如果频率太高，频繁写入磁盘和创建子进程会带来额外的性能开销。

在 Redis 4.0 提出的**混合使用 AOF 日志和内存快照**，也叫混合持久化。当开启了混合持久化时，在 AOF 重写日志时，`fork` 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。也就是说，使用了混合持久化，AOF 文件的**前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据**。

这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样**加载的时候速度会很快**。

加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得**数据更少的丢失**。

