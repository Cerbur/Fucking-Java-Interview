# 操作系统进程线程知识

## 进程的状态模型

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210715171542.png)

进程的五状态模型

- 创建状态（*new*）：进程正在被创建时的状态；

- 运行状态（*Runing*）：该时刻进程占用 CPU；
- 就绪状态（*Ready*）：可运行，但因为其他进程正在运行而暂停停止；
- 阻塞状态（*Blocked*）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；
- 结束状态（*Exit*）：进程正在从系统中消失时的状态；

再来详细说明一下进程的状态变迁：

- *NULL -> 创建状态*：一个新进程被创建时的第一个状态；
- *创建状态 -> 就绪状态*：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的；
- *就绪态 -> 运行状态*：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运行该进程；
- *运行状态 -> 结束状态*：当进程已经运行完成或出错时，会被操作系统作结束状态处理；
- *运行状态 -> 就绪状态*：处于运行状态的进程在运行过程中，由于分配给它的运行时间片用完，操作系统会把该进程变为就绪态，接着从就绪态选中另外一个进程运行；
- *运行状态 -> 阻塞状态*：当进程请求某个事件且必须等待时，例如请求 I/O 事件；
- *阻塞状态 -> 就绪状态*：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；

另外，还有一个状态叫**挂起状态**，它表示进程没有占有物理内存空间。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。

由于虚拟内存管理原因，进程的所使用的空间可能并没有映射到物理内存，而是在硬盘上，这时进程就会出现挂起状态，另外调用 sleep 也会被挂起。

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210715171726.png)

虚拟内存管理-换入换出

挂起状态可以分为两种：

- 阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；
- 就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；

这两种挂起状态加上前面的五种状态，就变成了七种状态变迁（留给我的颜色不多了），见如下图：

![](https://raw.githubusercontent.com/Cerbur/pic/main/20210715171715.png)

七种状态变迁

## PCB

**进程控制块**（*process control block，PCB*），**PCB 是进程存在的唯一标识**，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。

### PCB中包含的信息

进程描述信息

1. 进程标识符
2. 用户标识符

进程控制和管理信息

1. 进程当前状态
2. 进程优先级

资源分配清单

1. 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。

CPU 相关信息

1. CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。

PCB 通常是通过**链表**的方式进行组织，把具有**相同状态的进程链在一起，组成各种队列**。比如：

- 将所有处于就绪状态的进程链在一起，称为**就绪队列**；
- 把所有因等待某事件而处于等待状态的进程链在一起就组成各种**阻塞队列**；
- 另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。

## 进程的上下文切换

进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。

## 多进程优点

1. 每个进程互相独立，不影响主程序的稳定性，子进程崩溃没关系；

2. 通过增加CPU，就可以容易扩充性能；
3. 可以尽量减少线程加锁/解锁的影响，极大提高性能，就算是线程运行的模块算法效率低也没关系；
4. 每个子进程都有2GB地址空间和相关资源，总体能够达到的性能上限非常大

## 多进程缺点

1. 逻辑控制复杂，需要和主程序交互；
2. 需要跨进程边界，如果有大数据量传送，就不太好，适合小数据量传送、密集运算
3. 多进程调度开销比较大；

## 线程

**线程是进程当中的一条执行流程。**

同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程都有独立一套的寄存器和栈，这样可以确保线程的控制流是相对独立的。

## 线程的优点

1. 一个进程中可以同时存在多个线程；
2. 各个线程之间可以并发执行；
3. 各个线程之间可以共享地址空间和文件等资源；

## 线程的缺点

1. 当进程中的一个线程奔溃时，会导致其所属进程的所有线程奔溃。
2. 线程的内存大小限制与进程大小的分配。

## 线程与进程的比较

**线程是调度的基本单位，而进程则是资源拥有的基本单位**。

1. 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；
2. 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
3. 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；
4. 线程能减少并发执行的时间和空间开销；

对于，线程相比进程能减少开销，体现在：

- 线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；
- 线程的终止时间比进程快，因为线程释放的资源相比进程少很多；
- 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；
- 由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；

## 线程的上下文切换

我猜的切换所做的事情，保留现场，首先要记录程序计数器，记录执行到了哪里，然后就是保存所有的用的现场栈空间所产生的变量数据。

这还得看线程是不是属于同一个进程：

- 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；
- **当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**；


## 进程调度算法

1. 先来先服务
2. 短作业优先
3. 高响应比优先调度算法
4. 时间片轮转算法
5. 最高优先级调度算法
6. 多级反馈队列调度算法